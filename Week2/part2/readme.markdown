# RISC-V BabySoC Implementation Analysis

This document provides an analysis of the RISC-V BabySoC implementation, focusing on the reset operation, clocking, and dataflow between modules based on the provided Verilog code and associated files. Since waveform screenshots cannot be generated directly here, the expected behavior is described, along with suggestions for waveform observations using a simulation tool like Icarus Verilog (as indicated by the `vvp` output).

## 1. Reset Operation

### Mechanism
- The reset operation is controlled by the `reset` input signal in the `vsdbabysoc_tb` testbench and propagated to the `rvmyth` core module.
- In the `rvmyth` module, `CPU_reset_a0` is assigned directly from the `reset` input at stage `@0`, initializing the system state:
  - Register file (`CPU_Xreg_value_a3`) is reset to the register index value (e.g., `xreg` value) when `CPU_reset_a3` is active.
  - Program counter (`CPU_pc_a0`) is set to `32'd0` when `CPU_reset_a1` is true.
  - Data memory (`CPU_Dmem_value_a4`) is initialized to the memory address value (`dmem`) on reset.
- **Testbench Behavior**: The testbench sets `reset = 0` initially, then toggles it to `1` at `#20` and back to `0` at `#100`, resetting the system and allowing execution to start.

### Observation
- During the reset period (`reset = 1`), expect `CPU_pc_a0` to hold at `0x00000000`, and register values in `CPU_Xreg_value_a3` to reflect their index (e.g., `x0 = 0`, `x1 = 1`, etc.).
- After reset deasserts (`reset = 0`), the program counter should increment, and register values should update based on executed instructions.

### Waveform Suggestion
- Monitor `reset`, `CPU_reset_a0`, `CPU_pc_a0`, and `CPU_Xreg_value_a3[17]` (since `OUT` is tied to `Xreg_value_a5[17]`) from `t=0` to `t=200` to capture the reset transition.

## 2. Clocking

### Source
- The clock (`CLK`) is generated by the `avsdpll` module, acting as a Phase-Locked Loop (PLL), derived from the `VCO_IN` input and modulated by `ENb_VCO` and `REF` signals.

### PLL Behavior
- The `CLK` toggles with a period initially set to `25.0ns` (40MHz) and updated to `refpd / 8.0` on each rising edge of `REF`.
- The testbench toggles `REF` every `#100` units and `VCO_IN` every `#(83.33/2)` units, simulating a reference clock and VCO input.
- `ENb_VCO` is set to `1` during the simulation, enabling clock generation.
- The `CLK` signal is passed to the `rvmyth` core, driving synchronous operations (e.g., register file writes on `posedge CLK`).

### Observation
- The `CLK` signal should exhibit a stable toggle pattern after the initial period adjustment, with a frequency approximately 1/8th of the `REF` period (e.g., if `REF` period is `100ns`, `CLK` period should be around `12.5ns`).
- The `OUT` signal (from `avsddac`) should update on `CLK` edges after the reset.

### Waveform Suggestion
- Observe `CLK`, `REF`, `VCO_IN`, and `OUT` from `t=0` to `t=600` to verify clock generation and its effect on the output.

## 3. Dataflow Between Modules

### Module Hierarchy
- `vsdbabysoc_tb` drives inputs (`reset`, `VCO_IN`, `ENb_CP`, `ENb_VCO`, `REF`, `VREFH`) and monitors `OUT`.
- `vsdbabysoc` integrates:
  - `rvmyth` core, processing RISC-V instructions and outputting a 10-bit value (`RV_TO_DAC`).
  - `avsdpll`, generating `CLK` from `VCO_IN` and `REF`.
  - `avsddac`, converting `RV_TO_DAC` to an analog `OUT` using `VREFH`.

### Dataflow
- **Instruction Fetch and Execute**: The `rvmyth` core fetches instructions from `CPU_Imem_instr_a1` (preloaded with 13 instructions, e.g., `ADDI`, `ADD`, `BNE`) using `CPU_pc_a0`. The ALU computes results (`CPU_result_a3`), and the register file (`CPU_Xreg_value_a3`) is updated. The value of `Xreg_value_a5[17]` is assigned to `OUT` via the testbench.
- **Clock Distribution**: `CLK` from `avsdpll` synchronizes the `rvmyth` core's pipeline stages (`@0` to `@5`).
- **DAC Conversion**: `RV_TO_DAC` (10 bits from `rvmyth`) is fed to `avsddac`, which scales it between `VREFL` (0.0) and `VREFH` (3.3) to produce `OUT`.
- **Instruction Sequence**: The code includes a loop (e.g., `BNE` at instruction #6 and #10) iterating from `r11 = 0` to `r10 = 101011`, performing `ADD` and `SUB` operations on `r17`. The final `BEQ` at #12 may terminate the loop.

### Observation
- Expect `OUT` to reflect the value of `Xreg_value_a5[17]`, which should change as the loop executes.
- The data memory (`CPU_Dmem_value_a4`) may be written to during store instructions (e.g., `sw`).

### Waveform Suggestion
- Track `CPU_pc_a0`, `CPU_instr_a1`, `CPU_result_a3`, `CPU_Xreg_value_a5[17]`, `RV_TO_DAC`, and `OUT` from `t=100` (post-reset) to `t=600` to see instruction execution and data propagation.

## General Notes
- The simulation runs for 600 cycles (`repeat(600)` in the testbench), with `VCO_IN` and `REF` toggling to drive the PLL. The `$finish` at the end terminates the simulation.
- To generate waveforms, use a tool like GTKWave after running `vvp` with the `.vcd` file (e.g., `pre_synth_sim.vcd` or `post_synth_sim.vcd`).
- Key signals to probe include `reset`, `CLK`, `CPU_pc_a0`, `CPU_Xreg_value_a5[17]`, and `OUT` to validate reset, clocking, and dataflow.

## Simulation Instructions
- Compile the design using Icarus Verilog (e.g., `iverilog -o sim vsdbabysoc_tb.v rvmyth.v avsdpll.v avsddac.v`).
- Run the simulation with `vvp sim` to generate the `.vcd` file.
- Open the `.vcd` file in GTKWave and add the suggested signals to the waveform viewer for detailed analysis.

This analysis provides a foundation for understanding the BabySoC's behavior, with waveform suggestions to confirm the described functionality.

---

### Deliverable: Contents

#### 1. Simulation Logs
The simulation logs document the compilation and execution process. Based on your output, include the following:

- **Compilation and Initial Error Log**:
  - **File**: `simulation/compilation_log.txt`
  - **Content**:
  
 pavithra@pavithra-Lenovo-E41-55:~/VSDBabySoC$ make pre_synth_sim
sandpiper-saas -i src/module/rvmyth.tlv -o rvmyth.v 
--bestsv --noline -p verilog --outdir output/compiled_tlv
Please review our Terms of Service: https://makerchip.com/terms/.
Have you read and do you accept these Terms of Service? [y/N]: y
You have agreed to our Terms of Service here: https://makerchip.com/terms.
INFORM(0) (PROD_INFO):
SandPiper(TM) 1.14-2022/10/10-beta-Pro from Redwood EDA, LLC
(DEV) Run as: "java -jar sandpiper.jar --bestsv --noline -p verilog --outdir=out --nopath -i ./rvmyth.m4out.tlv -o rvmyth.v
For help, including product info, run with -h.
INFORM(0) (LICENSE):
Licensed to "Redwood EDA, LLC" as: Full Edition.
INFORM(0) (FILES):
Reading "./rvmyth.m4out.tlv"
to produce:
Translated HDL File: "out/rvmyth.v"
Generated HDL File: "out/rvmyth_gen.v"
if [ ! -f "output/pre_synth_sim/pre_synth_sim.vcd" ]; then 
mkdir -p output/pre_synth_sim; 
iverilog -o output/pre_synth_sim/pre_synth_sim.out -DPRE_SYNTH_SIM 
src/module/testbench.v 
-I src/include -I src/module -I output/compiled_tlv; 
cd output/pre_synth_sim; ./pre_synth_sim.out; 
fi
VCD info: dumpfile pre_synth_sim.vcd opened for output.

- **Notes**: The log shows the successful execution of SandPiper to generate `rvmyth.v` and `rvmyth_gen.v`, followed by the compilation and simulation using `iverilog` and `vvp`. The simulation started, and a `.vcd` file (`pre_synth_sim.vcd`) was opened for output. The log cuts off before completion (e.g., no `$finish` or end time), so ensure the simulation finished by checking the `pre_synth_sim.vcd` file size or running it again to confirm.

- **VCD File**:
- **File**: `output/pre_synth_sim/pre_synth_sim.vcd`
- **Notes**: This file contains the waveform data. Verify its presence and size (non-zero) to ensure the simulation completed. If incomplete, rerun `make pre_synth_sim`.

- **Next Steps**:
- The initial `iverilog` error suggests reviewing the repository structure. Check if `baby_soc.v` should be `vsdbabysoc.v` or if the testbench (`tb_baby_soc.v`) needs adjustment. The `make` command worked, so use its file list as a reference.
- Run `vvp output/pre_synth_sim/pre_synth_sim.out` manually if needed, and capture the full output (including `$finish`) for the log.

---

#### 2. GTKWave Screenshots Highlighting Correct BabySoC Behavior
Using the generated `pre_synth_sim.vcd`, open it in GTKWave to create screenshots. Based on the analysis, include:

- **Reset Operation Screenshot (t = 0–200 ns)**:
- **File**: ![reset behaviour](reset_behav.png)
- **Content**: Show `reset`, `CPU_reset_a0`, `CPU_pc_a0`, and `CPU_Xreg_value_a3[17]`. Zoom to t=0–200 ns, highlighting `reset = 1` (t=20–120 ns) holding PC at 0x00000000 and registers at initialized values, with PC incrementing post-reset.
- **Steps**: In GTKWave, load `pre_synth_sim.vcd`, expand the hierarchy to find `core > cpu`, add signals, set time markers at 20 ns and 120 ns, and export via **File > Write Image**.

- **Clocking Screenshot (t = 0–600 ns)**:
- **File**: ![clock ](clk_behav.png)
- **Content**: Display `CLK`, `REF`, `VCO_IN`, `ENb_VCO`, and `OUT`. Use a full view (t=0–600 ns) or zoom to t=100–300 ns, showing CLK stabilizing (~12.5 ns period) and OUT updating post-reset.
- **Steps**: Add PLL-related signals, use "Translate Filter" for labels, and export the image.

- **Dataflow Between Modules Screenshot (t = 100–600 ns)**:
- **File**: ![data flow between  odules](data_flow.png)
- **Content**: Include `CPU_pc_a0`, `CPU_instr_a1`, `CPU_result_a3`, `CPU_Xreg_value_a5[17]`, `RV_TO_DAC`, and `OUT`. Capture a loop iteration (e.g., BNE) showing data flow from core to DAC.
- **Steps**: Group signals into buses, add cursors for PC increments, and save the screenshot.

- **Verification**:
- Ensure the `.vcd` file contains all signals (check with `$dumpvars` in `testbench.v`). If signals are missing, update the testbench to dump the hierarchy (e.g., `$dumpvars(1, core)`).

- **Simulation Output Screenshot**:
- **File**: ![simulation output](sim_output.png)
- **Content**: Displays the terminal output from `make pre_synth_sim`, including SandPiper compilation and VCD generation steps.
- **Steps**: Capture the terminal during simulation execution.

- **Simulation Log Screenshot**:
- **File**: ![simulation log](simulation_log.png)
- **Content**: Captures the detailed simulation log, confirming "VCD info: dumpfile pre_synth_sim.vcd opened for output" and runtime progress.
- **Steps**: Export the GTKWave log view or terminal output as an image.

---

#### 3. Short Explanation (per Screenshot) of What the Waveform Represents
Provide concise descriptions for each screenshot:

- **Reset Operation (t = 0–200 ns)**:
- **Explanation**: This waveform represents the reset phase, where `reset` is high (t=20–120 ns), holding `CPU_pc_a0` at 0x00000000 and initializing registers (e.g., `CPU_Xreg_value_a3[17]` to 17). Post-reset (t>120 ns), PC increments, confirming synchronous reset and clean execution start.

- **Clocking (t = 0–600 ns)**:
- **Explanation**: This waveform represents clock generation, showing `CLK` stabilizing (~12.5 ns period) from `REF` and `VCO_IN` toggles, with `OUT` updating on CLK edges post-reset, validating PLL-driven synchronization.

- **Dataflow Between Modules (t = 100–600 ns)**:
- **Explanation**: This waveform represents pipeline dataflow, with `CPU_pc_a0` incrementing, `CPU_instr_a1` fetching instructions (e.g., ADDI/BNE), `CPU_result_a3` computing ALU results, and data propagating to `RV_TO_DAC`/`OUT`, confirming core-to-DAC integration.



  
  
  
  
  
  
  
